---
title: 'Assignment: McEliece Cryptosystems, Due Wednesday, 11:59pm'
author: "Jared Wada"
date: "December 7, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA)
library(gmp)
library(cryptoJKAW)
```

## 1. Random Linear Codes

An $[n,k]$ *random linear code* is a binary linear code with generating matrix of the form $\begin{bmatrix} I_k & P \end{bmatrix}$, where the rows of $P$ are $2i$-dimensional binary vectors of weight $i$, chosen at random, where $2i=n-k$.

a. Explain why the distance of such a code cannot exceed $(n-k)/2+1$. 

Beacuse the first part of the generating matrix is the identity of length k, we know that the weight of P cannot exceed cannot exceed n - k. The i is equal to n-k/2, so if you add the 1 weight from the identity matrix half, each row cannot exceed a weight greater than $$(n-k)/2+1$$

b. Find a generating matrix for a $[21, 5]$ random linear code with distance $9$. Show how you produced your example.

```{r}
n <- 21
k <- 5

i <- 16/2

generateP <- function(k, i, nk){
Ik <- diag(k)
tm <- vector()
for(i in 1:5){
  tm <- append(tm, randBinVector(nk, i))
}  
P <- matrix(tm, nrow=k, byrow = TRUE)
gener <- cbind(Ik, P)
total <- codeDistance(gener)

return(codeDistance(generateCode(gener)))
}
for(i in 1:100){
 # cat(generateP(5,8,16), "\n")
}


```

c. Does syndrome decoding offer any advantage over brute force nearest neighbor decoding for this code? Explain.

## 2. McEliece cryptosystem

Illustrate the seven steps of the McEliece public key cryptosystem using the code generated by the matrix `bch15` from Problem 1 of the last assignment. Make and state all of the required choices: the message Alice wants to send, the choices Bob makes to obtain the public key, and the random vector Alice uses. Use the functions `randBinVector`, `randInvMatrix`, and `randPermMatrix` appropriately. Show the results of all the intermediate calculations, and confirm that decoding works properly.

```{r}
G <- matrix(c(1,0,0,0,0,1,1,1,0,1,1,0,0,1,0,
                  0,1,0,0,0,0,1,1,1,0,1,1,0,0,1,
                  0,0,1,0,0,1,1,0,1,0,1,1,1,1,0,
                  0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,
                  0,0,0,0,1,1,1,0,1,1,0,0,1,0,1),
                byrow=TRUE, nrow=5)
codeMatrix <- generateCode(G)
n <- ncol(G)
k <- nrow(G)
t <- 3
```
1. Bob chooses the codewords of the bch15 matrix as his [n,k] matrix that can correct 3 errors. The original bch15 matrix is his generator matrix G.

```{r}
S <- randInvMatrix(k)[[1]]
Sinv <- solve(S) %% 2
P <- randPermMatrix(n)
Pinv <- solve(P) %% 2
```
2. Here Bob chose a random invertible k by k binary matrix S, and a random n by n permutation matrix P.
```{r}
G1 <- (S %*% G) %*% P
```
3. Bob computes G1 as a dot product of SGP and makes G1 public while S, G, and P stay private.
```{r}
e <- randBinVector(n, t)
x <- randBinVector(k, 3)
y <- (x %*% G1) + e %% 2
```
4. Alice comes up with message x (a k dimensional row vector), and error code vector e with weight of t and length of n.
She then sends y, which is e added to the dot product of x and G1.
```{r}
y1 <- y %*% Pinv %% 2

```
5. Bob computes y1 value by taking the dot product of y and the inverse of P.
```{r}
syn <- y1 %*% t(parityCheckMatrix(G)) %% 2
syn <- paste(syn,collapse="")
l <- cosetLeaderSyndromeTable(G)
n <- match(syn, names(l))
test <- l[[n]]
x1 <- as.numeric(xor(test, y1))
```
6. Bob uses efficient algorithm (syndrome decoding) to find the codeword x1 from y1.
```{r}
x0 <- x1[1:5] %% 2
mDecode <- x0 %*% Sinv %% 2
isTRUE(all.equal(x, mDecode[1,]))

```
7. Bob takes the first k digits of x1 to get x0. He then computes the original message x by multiplying by the inverse of S.

## 3. McEliece with Goppa Codes

Suppose Bob implements a McEliece cryptosystem using a Goppa code with parameters $m=7$ and $t=15$.

a. How long is this code? How many errors can it correct? How many code words are there?
```{r}
m <- 7
t <- 15
n <- 2^m # The length
k <- n - (m*t) # number of codes
d <- ((2*t - 1) + 1)/2# Errors it can correct
n
k
d
```
b. When Alice sends a message, she chooses a random error vector $e$. How many different possible error vectors can she choose from?

```{r}
choose(n, n-d)
```

c. Suppose that Eve attempts a brute force attack to find the plaintext $x$ by calculating all possible ciphertext messages that Alice could send. How many different ciphertexts of the form $y=xG_1+e$ are there, as $x$ ranges over all possible plaintexts and as $e$ ranges over all possible error vectors?
(Note that even though this number seems large, the parameters given in this example are too small to be used in practice.)
```{r}
2^128 * choose(n, n-d)
```

## 4. Identify this cyclic code

a. Show that $x^2+x+1$ is a factor of $x^3+1$.

$$ (x^3+1) \div (x^2+x+1)  $$
$$ (x^3+1) - (x^3+x^2+x) = (x^2+x+1)$$
$$ (x^2+x+1) - (x^2+x+1) = 0$$

Thus, $x^2+x+1$ is a factor of $x^3+1$.

b. Find all the code words of the cyclic code corresponding to the ideal $\langle x^2+x+1 \rangle$ of  $\mathbb{Z}_2[x]/(x^3+1)$. Write these code words as binary strings. Which familiar code is this?

$$x+1$$
$$* x$$
$$= x^2+x$$
$$* x$$
$$= x^3+x^2$$
$$= x^2+1$$
$$* x$$
$$= x^3+x$$
$$= x+1$$
The codes are 110, 101, 011, and 000. 

## 5. Parity check polynomial

Consider the cylic code corresponding to the ideal $\langle x+1 \rangle$ in  $\mathbb{Z}_2[x]/(x^4+1)$. 

a. Find a parity check polynomial for this code.
$$x^4+1 \div x+1$$
$$(x^4+1) - (x^4+x^3) = (x^3+1) R x^3$$
$$(x^3+1) - (x^3+x^2) = (x^2+1) R x^2$$
$$(x^2+1) - (x^2+x) = (x+1) R x$$
$$(x+1) - (x+1) = 0 R 1$$
$$x^3+x^2+x+1$$
b. Use your parity check polynomial to determine whether each of the following is a code word:
    $$x^4 = 1$$
    $$x^5 = x$$
    $$x^6 = x^2$$
    - $1+x+x^3$
    $$* x^3+x^2+x+1$$
    $$= x^6+x^5+2x^4+3x^3+2x^2+2x+1$$
    $$= x^2+x+0+x^3+0+0+1$$
    $$= x^3+x^2+x+1$$
    This is not a codeword
    - $x+x^2$
    $$* x^3+x^2+x+1$$
    $$= x^5+2x^4+2x^3+2x^2+x$$
    $$= x+0+0+0+x$$
    $$= 0$$
    This is a codeword
